<template>
  <SeamlessInput
    :value="valueString"
    :placeholder="placeholder"
    :disabled="!editable"
    class="text-right transition-all duration-300 ease-in-out"
    @value-changed="handleValueStringChanged"
  >
    <template
      v-if="enableConvertRate"
      #post
    >
      <NcActions
        type="tertiary-no-background"
        :disabled="!editable"
      >
        <template #icon>
          <SwapHorizontal />
        </template>

        <NcActionInput
          :value.sync="convertRateString"
          :label="t('money', 'Convert rate')"
          @submit="handleConvertRateStringChanged"
        >
          <template #icon>
            <SwapHorizontal />
          </template>
          {{ t('money', 'Convert rate') }}...
        </NcActionInput>

        <NcActionInput
          :value.sync="foreignValueString"
          :label="t('money', 'Foreign value')"
          @submit="handleForeignValueStringChanged"
        >
          <template #icon>
            <CashMultiple />
          </template>
          {{ t('money', 'Foreign value') }}...
        </NcActionInput>
      </NcActions>
    </template>
  </SeamlessInput>
</template>

<script setup lang="ts">

  import { computed, onMounted, ref, watch } from 'vue';

  import { useSettingStore } from '../stores/settingStore';

  import { useMathExpression } from '../utils/mathExpression';
  import { NumberUtils } from '../utils/numberUtils';

  import NcActions from '@nextcloud/vue/dist/Components/NcActions';
  import NcActionInput from '@nextcloud/vue/dist/Components/NcActionInput';

  import SwapHorizontal from 'vue-material-design-icons/SwapHorizontal.vue';
  import CashMultiple from 'vue-material-design-icons/CashMultiple.vue';

  import SeamlessInput from './SeamlessInput.vue';

  const mathExpression = useMathExpression();
  const settingStore = useSettingStore();

  const props = defineProps({
    value: {
      type: Number,
      required: true
    },
    editable: {
      type: Boolean,
      default: true
    },
    placeholder: {
      type: String,
      default: ''
    },
    invertedValue: {
      type: Boolean,
      default: false
    },
    enableConvertRate: {
      type: Boolean,
      default: false
    },
    convertRate: {
      type: Number,
      default: 1.0
    }
  });

  const emit = defineEmits([
    'value-changed',
    'convert-rate-changed'
  ]);

  const valueString = ref('');

  const convertRateString = ref('');
  const foreignValueString = ref('');

  const foreignValue = computed(() => {
    return props.value * props.convertRate;
  });

  const formattedValueString = computed(() => {
    return NumberUtils.formatNumber(props.value, getSettings());
  });

  const formattedConvertRateString = computed(() => {
    return NumberUtils.formatNumber(props.convertRate, getSettings(2));
  });

  const formattedForeignValueString = computed(() => {
    return NumberUtils.formatNumber(foreignValue.value, getSettings());
  });

  watch(formattedValueString, () => {
    valueString.value = formattedValueString.value;
  });

  watch(formattedConvertRateString, () => {
    convertRateString.value = formattedConvertRateString.value;
  });

  watch(formattedForeignValueString, () => {
    foreignValueString.value = formattedForeignValueString.value;
  });

  function getSettings(decimalsFactor = 1) {
    return {
      decimals: settingStore.numberFormat_decimals * decimalsFactor,
      decimalSeparator: settingStore.numberFormat_decimalSeparator,
      groupBy: settingStore.numberFormat_groupBy,
      groupSeparator: settingStore.numberFormat_groupSeparator,
      invertedValue: props.invertedValue
    };
  }

  function handleValueStringChanged(newValue: string) {
    const newNumber = getNumberFromExpression(newValue, props.value);
    if (Number.isNaN(newNumber)) return;

      emit(
      'value-changed',
      props.invertedValue ? newNumber * -1.0 : newNumber
    );
  }

  function handleConvertRateStringChanged() {
    const newConvertRate = getNumberFromExpression(convertRateString.value, props.convertRate);
    if (Number.isNaN(newConvertRate)) return;

    emit(
      'convert-rate-changed',
      newConvertRate
    );
  }

  function handleForeignValueStringChanged() {
    const newForeignValue = getNumberFromExpression(foreignValueString.value, foreignValue.value);
    if (Number.isNaN(newForeignValue)) return;

    const newConvertRate = NumberUtils.areEqual(props.value, 0.0) ? 1.0 : newForeignValue / props.value;

    emit(
      'convert-rate-changed',
      newConvertRate
    )
  }

  function getNumberFromExpression(stringValue: string, initialValue?: number): number {
    return mathExpression.evaluate(stringValue, initialValue);
  }

  onMounted(() => {
    valueString.value = formattedValueString.value;
    convertRateString.value = formattedConvertRateString.value;
    foreignValueString.value = formattedForeignValueString.value;
  });

</script>
